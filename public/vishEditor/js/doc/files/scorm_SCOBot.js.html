<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>scorm&#x2F;SCOBot.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/VISH.Editor.html">VISH.Editor</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ViSH.html">ViSH</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: scorm&#x2F;SCOBot.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*global $, JQuery, scorm, window *&#x2F;
&#x2F;*jslint devel: true, browser: true, regexp: true *&#x2F;
&#x2F;**
 * This is a sample SCORM Startup sequence and handicap API&#x27;s for ease of use.
 * General Concept: When the LMS connects, call var SB = new SCOBot();
 * SCOBot
 * This only works with the SCORM_API, but has the basis to work with other API&#x27;s.
 * Several public API&#x27;s will call one to many SCORM Calls and this will make every attempt to
 * do common SCORM Tasks or boil down SCORM tasks into a smaller easy to use method.
 * Mode: {get} Browse, Review, Normal
 * Bookmark: {get&#x2F;set} SCO Progress
 * Suspend Data: {get&#x2F;set} Suspend Data Object
 * Interactions: {set} Interaction(s)
 * Objectives: {set} Objective(s)
 *
 * JSLint recently complained about  tabs.  Switched to spaces.
 *
 * https:&#x2F;&#x2F;github.com&#x2F;cybercussion&#x2F;SCOBot
 * @author Mark Statkus &lt;mark@cybercussion.com&gt;
 * @license Copyright (c) 2009-2014, Cybercussion Interactive LLC
 * As of 3.0.0 this code is under a Creative Commons Attribution-ShareAlike 4.0 International License.
 * @requires scorm, JQuery
 * @version 3.1.0
 * @param options {Object} override default values
 * @constructor
 *&#x2F;
&#x2F;*!
 * SCOBot, Updated January 3rd, 2014
 * Copyright (c) 2009-2013, Cybercussion Interactive LLC. All rights reserved.
 * As of 3.0.0 this code is under a Creative Commons Attribution-ShareAlike 4.0 International License.
 *&#x2F;
function SCOBot(options) {
    &#x2F;&#x2F; Constructor &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &quot;use strict&quot;;
    &#x2F;** @default version, createDate, modifiedDate, prefix, launch_data, interaction_mode, success_status, location, completion_status, suspend_data, mode, scaled_passing_score, totalInteractions, totalObjectives, startTime *&#x2F;
    var defaults = {
            version:              &quot;3.1.0&quot;,
            createDate:           &quot;04&#x2F;07&#x2F;2011 09:33AM&quot;,
            modifiedDate:         &quot;01&#x2F;16&#x2F;2014 03:57PM&quot;,
            prefix:               &quot;SCOBot&quot;,
            &#x2F;&#x2F; SCORM buffers and settings
            launch_data:          {},
            interaction_mode:     &quot;state&quot;, &#x2F;&#x2F; or journaled
            launch_data_type:     &quot;querystring&quot;, &#x2F;&#x2F; or json
            initiate_timer:       true,
            scorm_strict:         true, &#x2F;&#x2F; You can override this.  Will enforce SPM of SCORM Spec
            scorm_edition:        &quot;3rd&quot;, &#x2F;&#x2F; or 4th - this is a issue with &quot;editions&quot; of SCORM 2004 that differ
            success_status:       &quot;unknown&quot;, &#x2F;&#x2F; used as local status * see SCORM_API for override
            location:             &quot;&quot;,
            completion_status:    &quot;&quot;, &#x2F;&#x2F; used as local status * see SCORM_API for override
            suspend_data:         {pages: []},
            mode:                 &quot;&quot;,
            completion_threshold: 0,
            scaled_passing_score: 0.7,
            max_time_allowed:     &#x27;&#x27;,
            totalInteractions:    0,
            totalObjectives:      0,
            startTime:            0
        },
    &#x2F;&#x2F; Settings merged with defaults and extended options
        settings = $.extend(defaults, options),
        lmsconnected = false,
        isError = false,
        isStarted = false,
        badValues = &#x27;|null|undefined|false|NaN|| |&#x27;,
        error = scorm.get(&#x27;error&#x27;), &#x2F;&#x2F; no sense retyping this
        self = this; &#x2F;&#x2F; Hook
    &#x2F;&#x2F; End Constructor &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;&#x2F; Private &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;**
     * Initialize SCO
     * This is commonly done on load of the web page.
     * Default behavior
     * @event load
     * @returns {Boolean} true or false if established LMS connection
     *&#x2F;
    function initSCO() {
        lmsconnected = scorm.initialize();
        scorm.debug(settings.prefix + &quot;: SCO Loaded from window.onload &quot; + lmsconnected, 4);
        if (lmsconnected) {
            self.start(); &#x2F;&#x2F; Things you&#x27;d do like getting mode, suspend data
            &#x2F;&#x2F; Custom Event Trigger load
            $(self).triggerHandler({
                &#x27;type&#x27;: &quot;load&quot;
            });
        }
        return lmsconnected;
    }

    &#x2F;**
     * Exit SCO
     * Commonly done when unload or beforeunload is triggered
     * Default behavior
     * @event unload
     * @returns {Boolean} true or false if successfully exited
     *&#x2F;
    function exitSCO() {
        scorm.debug(&quot;SCO is being asked, *cough* forced to exit ...&quot;, 3);
        if (isStarted) {
            &#x2F;&#x2F; Custom Event Trigger load
            $(self).triggerHandler({
                &#x27;type&#x27;: &quot;unload&quot;
            });
            switch (scorm.get(&#x27;exit_type&#x27;)) {
            case &quot;finish&quot;:
                self.finish();
                break;
            case &quot;suspend&quot;:
                self.suspend();
                break;
            case &quot;timeout&quot;:
                self.timeout();
                break;
            default:
                scorm.debug(settings.prefix + &quot;: unknown exit type&quot;, 2);
                break;
            }
            scorm.debug(settings.prefix + &quot;: SCO is done unloading.&quot;, 4);
            isStarted = false;
        }
        return true;
    }

    &#x2F;**
     * Trigger Warning (internal to this API)
     * Throws a console log when a SCORM API Error occurs
     * @returns {Boolean}
     *&#x2F;
    function triggerWarning(n) {
        scorm.debug(error[n], 2);
        return true;
    }

    &#x2F;**
     * Trigger Exception
     * Throws an event the player can listen to in order to handle an exception.
     * This would be common to a non-compliance in an LMS and loss of student data.
     *&#x2F;
    function triggerException(msg) {
        $(self).triggerHandler({
            &#x27;type&#x27;:  &#x27;exception&#x27;,
            &#x27;error&#x27;: msg
        });
    }

    &#x2F;**
     * Is Performing
     * This is based on cmi.success_status
     * @returns {Boolean} based on if this value has been set (true) or (false) if not
     *&#x2F;
    function isPassed() {
        var success = scorm.getvalue(&#x27;cmi.success_status&#x27;);
        return !(success !== &quot;passed&quot; &amp;&amp; success !== &quot;failed&quot;);
    }

    &#x2F;**
     * Verify cmi score scaled
     * Validates if success_status is passed, and exit_type is normal.  Checks that score.max is 1.
     * May need to tighten this up later, its mostly for SCO&#x27;s that default to normal and expect them to be complete.
     *&#x2F;
    function verifyScoreScaled() {
        var success = scorm.getvalue(&#x27;cmi.success_status&#x27;);
        if (success === &#x27;passed&#x27; &amp;&amp; scorm.get(&#x27;exit_type&#x27;) === &quot;finish&quot;) {
            if (scorm.getvalue(&#x27;cmi.score.scaled&#x27;) === &#x27;false&#x27;) {
                if (scorm.getvalue(&#x27;cmi.score.max&#x27;) === &#x27;1&#x27;) {
                    scorm.setvalue(&#x27;cmi.score.scaled&#x27;, &#x27;1&#x27;);
                }
            }
        }
    }

    &#x2F;**
     * Is Bad Value
     * We get a variety of responses from an LMS
     * @returns {Boolean} true if its bad.
     *&#x2F;
    function isBadValue(v) {
        return badValues.indexOf(&#x27;|&#x27; + v + &#x27;|&#x27;) &gt;= 0;
    }

    &#x2F;**
     * Cleanse Data
     * This will escape out characters that may of been cross-contaminated from other proprietary sources.
     * These can often result in UTF-8 and other encoding issues and may result in errors.
     *&#x2F;
    function cleanseData(str) {
        var cleanseExp = &#x2F;[^\f\r\n\t\v\0\s\S\w\W\d\D\b\\B\\cX\\xhh\\uhhh]&#x2F;gi; &#x2F;&#x2F;&#x2F;(\f\r\n\t\v\0[&#x2F;b]\s\S\w\W\d\D\b\B\cX\xhh\uhhh)&#x2F;;
        return str.replace(cleanseExp, &#x27;&#x27;);
    }

    &#x2F;**
     * Is ISO 8601
     * I&#x27;ve got a RegEx to validate ISO 8601 time based on SCORM 2004 Formats.
     * This is a great common way to do this so regardless of time zone you can reflect the
     * time this time stamp was referring to.
     * Acceptable Format GMT 2012-02-28T15:00:00.0-8:00, UTC 2012-02-28T15:00:00.0-8:00Z, Plain 2012-02-28T15:00:00
     * @param v {String} ISO 8601 timestamp
     * @returns {Boolean} true or false
     *&#x2F;
    function isISO8601(v) {
        var iso8601Exp;
        switch (scorm.get(&#x27;time_type&#x27;)) {
        case &quot;UTC&quot;: &#x2F;&#x2F; AT GMT
            iso8601Exp = &#x2F;^(\d{4})-0?(\d+)-0?(\d+)[T ]0?(\d+):0?(\d+):0?(\d+)(?:\.(\d+))(|Z)$&#x2F;;
            break;
        case &quot;GMT&quot;: &#x2F;&#x2F; FROM GMT
            iso8601Exp = &#x2F;^(\d{4})-0?(\d+)-0?(\d+)[T ]0?(\d+):0?(\d+):0?(\d+)(?:\.(\d+))[\+\-]\d{2}:\d{2}$&#x2F;;
            break;
        default:    &#x2F;&#x2F; Now, regardless of GMT
            iso8601Exp = &#x2F;^(\d{4})-0?(\d+)-0?(\d+)[T ]0?(\d+):0?(\d+):0?(\d+)$&#x2F;;
            break;
        }
        return iso8601Exp.test(v);
    }

    &#x2F;**
     * is ISO 8601 Duration
     * This is a PT0H0M0S format
     * @param v {String}
     * @return {Boolean}
     *&#x2F;
    function isISO8601Duration(v) {
        var iso8601Dur = &#x2F;^(?:P)([^T]*)(?:T)?(.*)?$&#x2F;;
        return iso8601Dur.test(v);
    }

    &#x2F;**
     * Not Started Yet
     * You should never see this message, but I found I may need to trace this more than once.
     * @returns {String} &#x27;false&#x27;
     *&#x2F;
    function notStartedYet() {
        scorm.debug(settings.prefix + &quot;: You didn&#x27;t call &#x27;start()&#x27; yet, or you already terminated, ignoring.&quot;, 2);
        return &#x27;false&#x27;;
    }

    &#x2F;**
     * Current Time
     * @returns {Number} Milliseconds
     *&#x2F;
    function currentTime() {
        return (new Date().getTime());
    }

    &#x2F;**
     * True Round
     * May consider using this to fit within real(10,7) scoring in the event the decimal goes over 7 digits
     * @param v {Number} value
     * @param dec {Number} decimal places
     * @return {Number}
     *&#x2F;
    function trueRound(v, dec) {
        var num = parseFloat(v); &#x2F;&#x2F; ensure number
        return parseFloat(num.toPrecision(dec));
    }

    &#x2F;**
     * Find Response Type (May not use this)
     * This is designed to check for {case_matters: true&#x2F;false}, {order_matters: true&#x2F;false} or {lang: x}
     * @param type {String} order_matters, case_matters, lang
     * @param str {String}
     * @returns {Number}
     *&#x2F;
    function findResponseType(type, str) {
        var reg = 0;
        switch (type) {
        case &quot;order_matters&quot;:
            reg = &#x2F;^\{order_matters=.*?\}&#x2F;;
            break;
        case &quot;case_matters&quot;:
            reg = &#x2F;^\{case_matters=.*?\}&#x2F;;
            break;
        case &quot;lang&quot;:
            reg = &#x2F;^\{lang=.*?\}&#x2F;;
            break;
        default:
            scorm.debug(settings.prefix + &quot;: Sorry, this is not a valid Response type.&quot;, 1);
            break;
        }
        return reg.exec(str);
    }

    &#x2F;**
     * Times Up
     *&#x2F;
    function timesUp() {
        scorm.debug(&quot;Times Up!&quot;);
        var time_action = scorm.getvalue(&#x27;cmi.time_limit_action&#x27;).split(&#x27;,&#x27;),
            message = !!((time_action[1] === &quot;message&quot;));
        if (message) {
            $(self).triggerHandler({
                &#x27;type&#x27;: &quot;message&quot;,
                &#x27;text&#x27;: &quot;Time Limit Exceeded&quot;
            });
        }
        scorm.set(&#x27;exit_type&#x27;, &quot;timeout&quot;);
        if (time_action[0] === &quot;exit&quot;) {
            &#x2F;&#x2F; Force unload method to wrap player up and Terminate
            &#x2F;&#x2F; switch default exit type to time-out
            exitSCO();
        } else {
            $(self).triggerHandler({
                &#x27;type&#x27;: &quot;continue&quot;
            });
        }
    }

    &#x2F;**
     * Set Value By Interaction Type
     * This is a data filter to convert input formats into SCORM standard strings.  Please review each interaction for what it expects.
     * This will not enforce SCORM char limits, so please mind your logs if your doing something your not suppose to.
     * @param type {String} Expects true-false, choice, fill-in, long-fill-in, matching, performance, sequencing, likert, numeric, other
     * @param value {*} May take Array or Object of arrays depending
     * @returns {*} formatted value for interaction type or Boolean false
     *&#x2F;
    function encodeInteractionType(type, value) {
        var str = &#x27;&#x27;,
            str2 = &#x27;&#x27;,
            i = 0,
            arr = [],
            arr2 = [],
            len,
            index;
        switch (type) {
            &#x2F;*
             * True &#x2F; False
             * This will expect a {Boolean}, else it will throw error.
             *&#x2F;
        case &#x27;true-false&#x27;:
            value = value.toString();
            if (value === &#x27;true&#x27; || value === &#x27;false&#x27;) {
                return value;
            }
            scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing true or false for true-false.  I got &quot; + value + &quot; instead&quot;, 1);
            return &#x27;&#x27;;
            &#x2F;*
             *  Multiple Choice
             *  This will expect an {Array} value type [&quot;choice_a&quot;, &quot;choice_b&quot;]
             *&#x2F;
        case &#x27;choice&#x27;:
            &#x2F;*
             * Sequencing
             * This will expect an {Array}
             * Similar to multiple choice
             *&#x2F;
        case &#x27;sequencing&#x27;:
            &#x2F;&#x2F; a[,]b
            if ($.isArray(value)) {
                index = 0;
                &#x2F;&#x2F; Quck validation it doesn&#x27;t exceed array length 36
                if (value.length &gt; 36 &amp;&amp; settings.scorm_strict) {
                    scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re passing a sum of values that exceeds SCORM&#x27;s limit of 36 for this pattern.&quot;, 2);
                    value = value.slice(0, 36);
                }
                &#x2F;&#x2F; Quick validation of short_identifier_types
                for (index in value) {
                    if (value.hasOwnProperty(index)) {
                        if (value[index].length &gt; 10 &amp;&amp; settings.scorm_strict) {
                            scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re passing values that exceed SCORM&#x27;s limit of 10 characters.  Yours have &quot; + value[index].length + &quot;. I will truncate this as not to lose data.&quot;, 2);
                            value[index] = value[index].substring(0, 10);
                        }
                    }
                }
                str = value.join(&quot;[,]&quot;);
                value = str;
            } else {
                scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for sequencing&#x2F;choice.  I got &quot; + typeof value + &quot; instead\n&quot; + JSON.stringify(value), 1);
                value = &#x27;&#x27;;
            }
            return value;
            &#x2F;*
             * Fill In
             * This will expect an {Object} with optional values
             * {
             *      case_matters: true, &#x2F;&#x2F; optional {Boolean}
             *      order_maters: true, &#x2F;&#x2F; optional {Boolean}
             *      lang: &#x27;en-us&#x27;,      &#x2F;&#x2F; optional, can also be alternate letter lang code {String}
             *      words: [            &#x2F;&#x2F; required {Array}
             *          &#x27;word1&#x27;,
             *          &#x27;word2&#x27;
             *      ]
             * }
             *&#x2F;
        case &#x27;fill-in&#x27;:
            &#x2F;&#x2F; Word
            &#x2F;&#x2F; {case_matters=true}{order_matters=true}{lang=en-us}word1[,]word2
            if ($.isPlainObject(value)) {
                &#x2F;&#x2F; Check for case_matters
                if (value.case_matters !== undefined) {
                    str += &quot;{case_matters=&quot; + value.case_matters + &quot;}&quot;;
                }
                &#x2F;&#x2F; Check for order_matters
                if (value.order_matters !== undefined) {
                    str += &quot;{order_matters=&quot; + value.order_matters + &quot;}&quot;;
                }
                &#x2F;&#x2F; Check for lang
                if (value.lang !== undefined) {
                    str += &quot;{lang=&quot; + value.lang + &quot;}&quot;;
                }
                str += value.words.join(&quot;[,]&quot;);
                value = str;
            } else {
                scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a object type for fill in.  I got &quot; + typeof value + &quot; instead&quot;, 1);
                value = &#x27;&#x27;;
            }
            return value;
            &#x2F;*
             * Long Fill In
             * This will expect an {Object} with optional values
             * {
             *      case_matters: true,   &#x2F;&#x2F; Optional {Boolean}
             *      lang: &#x27;en-us&#x27;,        &#x2F;&#x2F; Optional, can also be alternate letter lang code {String}
             *      text: &#x27;Bunch of text&#x27; &#x2F;&#x2F; Required 4000 character limit {String}
             * }
             *&#x2F;
        case &#x27;long-fill-in&#x27;:
            &#x2F;&#x2F; Bunch of text...
            &#x2F;&#x2F; {case_matters=true}{lang=en}Bunch of text...
            if ($.isPlainObject(value)) {
                &#x2F;&#x2F; Check for case_matters
                if (value.case_matters !== undefined) {
                    str += &quot;{case_matters=&quot; + value.case_matters + &quot;}&quot;;
                }
                &#x2F;&#x2F; Check for lang
                if (value.lang !== undefined) {
                    str += &quot;{lang=&quot; + value.lang + &quot;}&quot;;
                }
                str += value.text;
                value = str;
            } else {
                scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a object type for long fill in.  I got &quot; + typeof value + &quot; instead&quot;, 1);
                value = &#x27;&#x27;;
            }
            return value;
            &#x2F;*
             * Matching
             * This will expect {Array} of {Array}&#x27;s
             * [
             *      [&#x27;tile1&#x27;, &#x27;target1&#x27;],
             *      [&#x27;tile2&#x27;, &#x27;target3&#x27;],
             *      [&#x27;tile3&#x27;, &#x27;target2&#x27;]
             * ]
             *&#x2F;
        case &#x27;matching&#x27;:
            &#x2F;&#x2F; tile1[.]target1[,]tile2[.]target3[,]tile3[.]target2
            if ($.isArray(value)) {
                len = value.length;
                i = 0;
                while (i &lt; len) {
                &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
                    if ($.isArray(value[i])) {
                        arr.push(value[i].join(&quot;[.]&quot;)); &#x2F;&#x2F; this isn&#x27;t working
                    } else {
                        scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for matching&#x2F;performance.  I got &quot; + typeof value + &quot; instead&quot;, 1);
                        return &#x27;&#x27;;
                    }
                    i += 1;
                }
                str = arr.join(&quot;[,]&quot;);
                value = str;
            } else {
                scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for matching&#x2F;performance.  I got &quot; + typeof value + &quot; instead&quot;, 1);
                value = &#x27;&#x27;;
            }
            return value;
            &#x2F;*
             * Performance
             * This will expect {Array} of {Array}&#x27;s
             * Similar to matching, but its optional to pass the step identifier
             * Correct Responses Pattern:
             * Correct Response Pattern: {Object}
             * {
             *  order_matters: false,
             *  answers: [
             *          [&quot;step_1&quot;, &quot;inspect wound&quot;],
             *          [&quot;step_2&quot;, &quot;clean wound&quot;],
             *          [&quot;step_3&quot;, &quot;apply bandage&quot;]
             *     ]
             * }
             * Learner Response: [
             *          [&quot;step_1&quot;, &quot;inspect wound&quot;],
             *          [&quot;step_2&quot;, &quot;clean wound&quot;],
             *          [&quot;step_3&quot;, &quot;apply bandage&quot;]
             * ]
             *&#x2F;
        case &#x27;performance&#x27;:
            &#x2F;&#x2F;
            if (!$.isArray(value)) { &#x2F;&#x2F; This would be a Correct Response Pattern
                &#x2F;&#x2F; Check for order_matters
                if (value.order_matters !== undefined) {
                    str += &quot;{order_matters=&quot; + value.order_matters + &quot;}&quot;;
                }
                if ($.isArray(value.answers)) {
                    len = value.answers.length;
                    i = 0;
                    &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
                    while (i &lt; len) {
                        if ($.isArray(value.answers[i])) {
                            &#x2F;&#x2F; Need to check if answer is object
                            if ($.isPlainObject(value.answers[i][1])) {
                                arr2 = [trueRound(value.answers[i][1].min, 7), trueRound(value.answers[i][1].max, 7)];
                                str2 = arr2.join(&quot;[:]&quot;);
                                value.answers[i][1] = str2;
                            }
                            arr.push(value.answers[i].join(&quot;[.]&quot;));
                        } else {
                            scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for performance correct response.  I got &quot; + typeof (value.answers[i]) + &quot; instead on &quot; + i, 1);
                            scorm.debug(value, 1);
                            return &#x27;&#x27;;
                        }
                        i += 1;
                    }
                    str += arr.join(&quot;[,]&quot;);
                } else {
                    scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for performance correct response.  I got &quot; + typeof value.answers + &quot; instead&quot;, 1);
                    scorm.debug(value, 1);
                }
            } else {
                if (typeof ($.isArray(value))) { &#x2F;&#x2F; This would be a Learner Response
                    len = value.length;
                    i = 0;
                    &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
                    while (i &lt; len) {
                        if ($.isArray(value[i])) {
                            arr.push(value[i].join(&quot;[.]&quot;)); &#x2F;&#x2F; this isn&#x27;t working
                        } else {
                            scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for performance learner response.  I got &quot; + typeof value[i] + &quot; instead on &quot; + i, 1);
                            scorm.debug(value, 1);
                            return &#x27;&#x27;;
                        }
                        i += 1;
                    }
                    str = arr.join(&quot;[,]&quot;);
                } else {
                    scorm.debug(settings.prefix + &quot;: Developer, you&#x27;re not passing a array type for performance learner response.  I got &quot; + typeof value + &quot; instead&quot;, 1);
                    value = &#x27;&#x27;;
                }
            }
            value = str;
            return value;
        &#x2F;**
         * Numeric
         * comments coming
         *&#x2F;
        case &#x27;numeric&#x27;:
            if (typeof value === &quot;number&quot;) {
                str = value.toString();
            } else if ($.isPlainObject(value)) {
                arr = [trueRound(value.min, 7), trueRound(value.max, 7)];
                str = arr.join(&quot;[:]&quot;);
            } else {
                &#x2F;&#x2F; Verify number to save some time.
                str = parseFloat(value);
                if (str === &quot;NaN&quot;) {
                    scorm.debug(settings.prefix + &quot;: Developer, your not passing a number for a numeric interaction.  I got &quot; + value + &quot; instead&quot;, 1);
                }
                str += &#x27;&#x27;; &#x2F;&#x2F; String
            }
            return str;
            &#x2F;*
             * LikeRT
             * No real hands on here, expects a {String}
             * This is like &#x27;other&#x27;, but expects a short identifier type
             *&#x2F;
        case &#x27;likert&#x27;:
            &#x2F;*
             * Other
             * This will take a {String} and recommended not to go beyond 4000 chars
             *&#x2F;
        case &#x27;other&#x27;:
            &#x2F;&#x2F; Anything up to 4000 characters
            return value.toString(); &#x2F;&#x2F; Do nothing, but ensure string
        default:
            &#x2F;&#x2F; Invalid
            scorm.debug(settings.prefix + &quot;: Sorry, invalid interaction type detected for &quot; + type + &quot; on &quot; + value, 1);
            return false;
        }
    }

    &#x2F;**
     * Decode Value By Interaction Type
     * This is a data filter to convert input formats from SCORM standard strings to there native JS equivalent.
     * @param type {String} Expects true-false, choice, fill-in, long-fill-in, matching, performance, sequencing, likert, numeric, other
     * @param value {String} SCORM 2004 Format for Interaction learner response, or pattern
     * @returns {*} formatted value for interaction type
     *&#x2F;
    function decodeInteractionType(type, value) {
        var i = 0,
            arr = [],
            obj = {},
            len,
            match = false;
        switch (type) {
        case &#x27;true-false&#x27;:
            return value;
        case &#x27;choice&#x27;:
        case &#x27;sequencing&#x27;:
            &#x2F;&#x2F; a[,]b to array
            arr = value.split(&quot;[,]&quot;);
            value = arr;
            return value;
            &#x2F;*
             * Fill In
             * This will expect an {Object} with optional values
             * {
             *      case_matters: true, &#x2F;&#x2F; optional {Boolean}
             *      order_maters: true, &#x2F;&#x2F; optional {Boolean}
             *      lang: &#x27;en-us&#x27;,      &#x2F;&#x2F; optional, can also be alternate letter lang code {String}
             *      words: [            &#x2F;&#x2F; required {Array}
             *          &#x27;word1&#x27;,
             *          &#x27;word2&#x27;
             *      ]
             * }
             *&#x2F;
        case &#x27;fill-in&#x27;:
            &#x2F;&#x2F; Word
            &#x2F;&#x2F; {case_matters=true}{order_matters=true}{lang=en-us}word1[,]word2
            &#x2F;&#x2F; Check for case_matters
            arr = findResponseType(&#x27;case_matters&#x27;, value);
            if (arr !== null) {
                if (arr[0].search(&#x2F;^\{case_matters=(true|false)\}$&#x2F;) !== -1) {
                    obj.case_matters = arr[0].substring(&#x27;{case_matters=&#x27;.length, arr[0].length - 1);
                    value = value.substring(arr[0].length, value.length); &#x2F;&#x2F; trim off
                    scorm.debug(&quot;=== case matters&quot; + value, 4);
                }
            }
            &#x2F;&#x2F; Check for order_matters
            arr = findResponseType(&#x27;order_matters&#x27;, value);
            if (arr !== null) {
                if (arr[0].search(&#x2F;^\{order_matters=(true|false)\}$&#x2F;) !== -1) {
                    obj.order_matters = arr[0].substring(&#x27;{order_matters=&#x27;.length, arr[0].length - 1);
                    value = value.substring(arr[0].length, value.length); &#x2F;&#x2F; trim off
                    scorm.debug(&quot;=== order matters&quot; + value, 4);
                }
            }
            &#x2F;&#x2F; Check for lang
            arr = findResponseType(&#x27;lang&#x27;, value);
            if (arr !== null) {
                if (arr[0].search(&#x2F;^\{lang=.*?\}$&#x2F;) !== -1) {
                    obj.lang = arr[0].substring(&#x27;{lang=&#x27;.length, arr[0].length - 1); &#x2F;&#x2F; returns language value
                    value = value.substring(arr[0].length, value.length); &#x2F;&#x2F; trim off
                }
            }
            obj.words = value.split(&quot;[,]&quot;);
            return obj;
            &#x2F;*
             * Long Fill In
             * This will expect an {Object} with optional values
             * {
             *      case_matters: true,   &#x2F;&#x2F; Optional {Boolean}
             *      lang: &#x27;en-us&#x27;,        &#x2F;&#x2F; Optional, can also be alternate letter lang code {String}
             *      text: &#x27;Bunch of text&#x27; &#x2F;&#x2F; Required 4000 character limit {String}
             * }
             *&#x2F;
        case &#x27;long-fill-in&#x27;:
            &#x2F;&#x2F; Bunch of text...
            &#x2F;&#x2F; {case_matters=true}{lang=en}Bunch of text...
            &#x2F;&#x2F; Check for case_matters
            arr = findResponseType(&#x27;case_matters&#x27;, value);
            if (arr !== null) {
                if (arr[0].search(&#x2F;^\{case_matters=(true|false)\}$&#x2F;) !== -1) {
                    obj.case_matters = arr[0].substring(&#x27;{case_matters=&#x27;.length, arr[0].length - 1);
                    value = value.substring(arr[0].length, value.length); &#x2F;&#x2F; trim off
                    scorm.debug(&quot;=== case matters&quot; + value, 4);
                }
            }
            &#x2F;&#x2F; Check for lang
            arr = findResponseType(&#x27;lang&#x27;, value);
            if (arr !== null) {
                if (arr[0].search(&#x2F;^\{lang=.*?\}$&#x2F;) !== -1) {
                    obj.lang = arr[0].substring(&#x27;{lang=&#x27;.length, arr[0].length - 1); &#x2F;&#x2F; returns language value
                    value = value.substring(arr[0].length, value.length); &#x2F;&#x2F; trim off
                }
            }
            obj.text = value;
            return obj;
            &#x2F;*
             * Matching
             * This will expect {Array} of {Array}&#x27;s
             * [
             *      [&#x27;tile1&#x27;, &#x27;target1&#x27;],
             *      [&#x27;tile2&#x27;, &#x27;target3&#x27;],
             *      [&#x27;tile3&#x27;, &#x27;target2&#x27;]
             * ]
             *&#x2F;
        case &#x27;matching&#x27;:
            &#x2F;&#x2F; tile1[.]target1[,]tile2[.]target3[,]tile3[.]target2
            arr = value.split(&quot;[,]&quot;);
            len = arr.length;
            i = 0;
            &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
            while (i &lt; len) {
                arr[i] = arr[i].split(&quot;[.]&quot;); &#x2F;&#x2F; this isn&#x27;t working
                i += 1;
            }
            return arr;
            &#x2F;*
             * Performance
             * This will expect {Array} of {Array}&#x27;s
             * Similar to matching, but its optional to pass the step identifier
             * Correct Response Pattern: {Object}
             * {
             *  order_matters: false,
             *  answers: [
             *      [&quot;step_1&quot;, &quot;inspect wound&quot;],
             *      [&quot;step_2&quot;, &quot;clean wound&quot;],
             *      [&quot;step_3&quot;, &quot;apply bandage&quot;]
             *  ]
             * }
             * Learner Response: [ {Array}
             *      [&quot;step_1&quot;, &quot;inspect wound&quot;],
             *      [&quot;step_2&quot;, &quot;clean wound&quot;],
             *      [&quot;step_3&quot;, &quot;apply bandage&quot;]
             * ]
             *&#x2F;
        case &#x27;performance&#x27;:
            &#x2F;&#x2F; {order_matters=false}tile1[.]target1[,]tile2[.]target3[,]tile3[.]target2
            &#x2F;&#x2F; Check for order_matters (located in the correct_response pattern)
            arr = findResponseType(&#x27;order_matters&#x27;, value);
            if (arr !== null) {
                if (arr[0].search(&#x2F;^\{order_matters=(true|false)\}$&#x2F;) !== -1) {
                    match = true; &#x2F;&#x2F; This is a correct_responses.n.pattern
                    obj.order_matters = arr[0].substring(&#x27;{order_matters=&#x27;.length, arr[0].length - 1);
                    value = value.substring(arr[0].length, value.length); &#x2F;&#x2F; trim off
                    scorm.debug(&quot;=== order matters&quot; + value, 4);
                }
            }
            arr = value.split(&quot;[,]&quot;);
            len = arr.length;
            i = 0;
            &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
            while (i &lt; len) {
                arr[i] = arr[i].split(&quot;[.]&quot;); &#x2F;&#x2F; this isn&#x27;t working
                i += 1;
            }
            if (match) {
                obj.answers = arr;
                return obj;
            }
            return arr;
        &#x2F;**
         * Numeric
         * This falls into a simple hand off
         *&#x2F;
        case &#x27;numeric&#x27;:
            &#x2F;*
             * LikeRT
             * No real hands on here, expects a {String}
             * This is like &#x27;other&#x27;, but expects a short identifier type
             *&#x2F;
        case &#x27;likert&#x27;:
            &#x2F;*
             * Other
             * This will take a {String} and recommended not to go beyond 4000 chars
             *&#x2F;
        case &#x27;other&#x27;:
            &#x2F;&#x2F; Anything up to 4000 characters
            return value; &#x2F;&#x2F; Do nothing
        default:
            &#x2F;&#x2F; Invalid
            scorm.debug(settings.prefix + &quot;: Sorry, invalid interaction type detected for &quot; + type + &quot; on &quot; + value, 1);
            return false;
        }
    }

    &#x2F;**
     * Set Suspend Data
     * This will set existing suspend data managed by escaping the values
     * @returns {String} true (success) false (fail)
     *&#x2F;
    function setSuspendData() {
        var result;
        &#x2F;&#x2F; May want to consider updating scoring here at this time
        result = scorm.setvalue(&#x27;cmi.suspend_data&#x27;, cleanseData(JSON.stringify(settings.suspend_data)));
        if (result === &#x27;true&#x27;) {
            scorm.debug(settings.prefix + &quot;: Suspend Data saved&quot;, 4);
            scorm.debug(settings.suspend_data, 4);
            return &#x27;true&#x27;;
        }
        return &#x27;false&#x27;;
    }

    &#x2F;**
     * Check Progress
     * This should be used sparingly.  Its going to total up the scoring real-time based on any interactions and objectives.
     * cmi.score.scaled,
     * cmi.success_status,
     * cmi.completion_status,
     * cmi.progress_measure
     * @returns {*} object or false string
     * {
     *  score_scaled      = &#x27;0&#x27;,
     *  success_status    = &#x27;failed&#x27;,
     *  progress_measure  = &#x27;0&#x27;,
     *  completion_status = &#x27;incomplete&#x27;
     * }
     *&#x2F;
    function checkProgress() {
        if (isStarted) {
            var scoreRaw = 0,
                tmpRaw = 0,
                &#x2F;&#x2F;scoreMax = 0,
                &#x2F;&#x2F;scoreMin = 0,
                scoreScaled = 1,
                progressMeasure,
                totalObjectivesCompleted = 0,
            &#x2F;&#x2F;totalKnownObjectives     = parseInt(scorm.getvalue(&#x27;cmi.objectives._count&#x27;), 10),
            &#x2F;&#x2F;totalKnownInteractions   = parseInt(scorm.getvalue(&#x27;cmi.interactions._count&#x27;), 10),
                i = 0,
                count;
            if (settings.totalInteractions === 0 || settings.totalObjectives === 0) {
                &#x2F;&#x2F; This is a non-starter, if the SCO Player doesn&#x27;t set these we are flying blind
                scorm.debug(settings.prefix + &quot;: Sorry, I cannot calculate Progress as the totalInteractions and or Objectives are zero&quot;, 2);
                return &#x27;false&#x27;;
            }
            &#x2F;&#x2F; Set Score Totals (raw, min, max) and count up totalObjectivesCompleted
            count = parseInt(scorm.getvalue(&#x27;cmi.objectives._count&#x27;), 10);
            scorm.debug(settings.prefix + &quot; Count is &quot; + count);
            if (count &gt; 0) {
                count = count - 1; &#x2F;&#x2F;subtract 1 (max count)
                &#x2F;&#x2F;for (i = count; i &gt;= 0; i -= 1) {
                i = count;
                while (i &gt;= 0) {
                    &#x2F;&#x2F; Count up totalObjectivesCompleted
                    &#x2F;&#x2F;scoreMax += parseInt(scorm.getvalue(&#x27;cmi.objectives.&#x27; + i + &#x27;.score.max&#x27;), 10); &#x2F;&#x2F; should be un-used, might validate
                    &#x2F;&#x2F;scoreMin += parseInt(scorm.getvalue(&#x27;cmi.objectives.&#x27; + i + &#x27;.score.min&#x27;), 10); &#x2F;&#x2F; should be un-used, might validate
                    tmpRaw = parseFloat(scorm.getvalue(&#x27;cmi.objectives.&#x27; + i + &#x27;.score.raw&#x27;));
                    scorm.debug(&#x27;Score Raw: &#x27; + tmpRaw);
                    if (!isNaN(tmpRaw)) {
                        scoreRaw += parseFloat(tmpRaw); &#x2F;&#x2F; Whoops, said Int instead of Float.  Updated 8&#x2F;14
                    } else {
                        scorm.debug(settings.prefix + &quot; We got a NaN converting objectives.&quot; + i + &quot;.score.raw&quot;, 2);
                    }
                    if (scorm.getvalue(&#x27;cmi.objectives.&#x27; + i + &#x27;.completion_status&#x27;) === &#x27;completed&#x27;) {
                        totalObjectivesCompleted += 1;
                    }
                    i -= 1;
                }
            }
            &#x2F;&#x2F; Set Score Raw
            scorm.debug(settings.prefix + &quot; Setting score &quot; + scorm.setvalue(&#x27;cmi.score.raw&#x27;, scoreRaw.toString()));
            &#x2F;&#x2F; Set Score Scaled
            if ((settings.scoreMax - settings.scoreMin) === 0) {
                &#x2F;&#x2F; Division By Zero
                scorm.debug(settings.prefix + &quot;: Division by Zero for scoreMax - scoreMin &quot; + settings.scoreMax, 2);
                scorm.setvalue(&#x27;cmi.score.scaled&#x27;, scoreScaled);
            } else {
                scoreScaled = ((scoreRaw - settings.scoreMin) &#x2F; (settings.scoreMax - settings.scoreMin)).toString();
                scorm.debug(settings.prefix + &quot;: Score Scaled = &quot; + scoreScaled, 3);
                scorm.setvalue(&#x27;cmi.score.scaled&#x27;, trueRound(scoreScaled, 7));
            }
            &#x2F;&#x2F; Set Progress Measure
            progressMeasure = (totalObjectivesCompleted &#x2F; settings.totalObjectives).toString();
            scorm.setvalue(&#x27;cmi.progress_measure&#x27;, trueRound(progressMeasure, 7));
            &#x2F;&#x2F; Set Completion Status
            settings.completion_status = (parseFloat(progressMeasure) &gt;= parseFloat(settings.completion_threshold)) ? &#x27;completed&#x27; : &#x27;incomplete&#x27;;
            scorm.setvalue(&#x27;cmi.completion_status&#x27;, settings.completion_status);
            &#x2F;&#x2F; Set Success Status
            settings.success_status = (parseFloat(scoreScaled) &gt;= parseFloat(settings.scaled_passing_score)) ? &#x27;passed&#x27; : &#x27;failed&#x27;;
            scorm.setvalue(&#x27;cmi.success_status&#x27;, settings.success_status);
            return {
                score_scaled:      scorm.getvalue(&#x27;cmi.score.scaled&#x27;),
                success_status:    scorm.getvalue(&#x27;cmi.success_status&#x27;),
                progress_measure:  scorm.getvalue(&#x27;cmi.progress_measure&#x27;),
                completion_status: scorm.getvalue(&#x27;cmi.completion_status&#x27;)
            };
        }
        return notStartedYet();
    }

    &#x2F;**
     * Get Comments From LMS
     * Checks to see if there are any comments from the LMS, and will
     * return a complete object back for use with a display.
     * @return {*} object or &#x27;false&#x27;
     *&#x2F;
    function getCommentsFromLMS() {
        if (isStarted) {
            var p1 = &quot;cmi.comments_from_lms.&quot;,
                count = scorm.getvalue(p1 + &#x27;_count&#x27;),
                response = [],
                obj = {},
                i;
            if (!isBadValue(count)) {
                return &#x27;false&#x27;;
            }
            count -= 1;
            i = 0;
            &#x2F;&#x2F;for (i = 0; i &lt;= count; i += 1) {
            while (i &lt;= count) {
                p1 += i + &#x27;.&#x27;;
                obj.comment = scorm.getvalue(p1 + &#x27;comment&#x27;);
                obj.location = scorm.getvalue(p1 + &#x27;location&#x27;);
                obj.timestamp = scorm.getvalue(p1 + &#x27;timestamp&#x27;);
                response.push(obj);
                obj = {};
                i += 1;
            }
            return response;
        }
        return notStartedYet();
    }

    &#x2F;**
     * Update Status
     * Rolled up success&#x2F;completion status functionality
     *&#x2F;
    function updateStatus() {
        verifyScoreScaled();
        if (!isPassed()) {
            scorm.setvalue(&#x27;cmi.success_status&#x27;, &#x27;unknown&#x27;);
        }
        &#x2F;&#x2F; Default success status
        if (scorm.get(&quot;success_status&quot;) === &#x27;passed&#x27;) {
            scorm.setvalue(&#x27;cmi.success_status&#x27;, &#x27;passed&#x27;);
        }
        &#x2F;&#x2F; Ensure if its not completed its incomplete
        if (scorm.getvalue(&#x27;cmi.completion_status&#x27;) !== &quot;completed&quot;) {
            scorm.setvalue(&#x27;cmi.completion_status&#x27;, &#x27;incomplete&#x27;); &#x2F;&#x2F;? May not want to do this (fail safe)
        }
        &#x2F;&#x2F; Default to completed if its the default status
        if (scorm.get(&quot;completion_status&quot;) === &quot;completed&quot;) {
            scorm.setvalue(&#x27;cmi.completion_status&#x27;, &#x27;completed&#x27;); &#x2F;&#x2F;? May not want to do this
        }
    }

    &#x2F;&#x2F; End Private &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;&#x2F; Public &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;**
     * Start (Internal API)
     * Initializes the SCORM Startup, and communicates with SCORM (cruise control)
     * and will begin to store some common used parameters for use later. Like:
     * 1. mode
     * 2. location (bookmark)
     * 3. scaled_passing_score
     * 4. suspend_data
     * 5. completion_status
     * 6. success_status
     * These can be obtained by asking SB.get(&#x27;location&#x27;); i.e. the name space for these after you start,
     * and during the session.
     * @returns {Boolean}
     *&#x2F;
    this.start = function () {
        var tmpCompletionThreshold = &#x27;&#x27;,
            tmpScaledPassingScore = &#x27;&#x27;,
            tmpLaunchData = &#x27;&#x27;;
        &#x2F;&#x2F;queryStringExp = &#x2F;\\?([^?=&amp;]+)(=([^&amp;#]*))?&#x2F;gi;
        scorm.debug(settings.prefix + &quot;: I am starting...&quot;, 3);
        if (!isStarted) {
            isStarted = true;
            &#x2F;&#x2F; Retrieve normal settings&#x2F;parameters from the LMS
            &#x2F;&#x2F; Get SCO Mode (normal, browse, review)
            settings.startTime = currentTime();
            tmpLaunchData = scorm.getvalue(&#x27;cmi.launch_data&#x27;);
            &#x2F;&#x2F; Turn this into a object and differ between json or querystring formats.
            if (settings.launch_data_type === &quot;json&quot;) {
                settings.launch_data = JSON.parse(tmpLaunchData);
            } else {
                &#x2F;*jslint unparam: true*&#x2F;
                tmpLaunchData.replace(
                    new RegExp(&quot;([^?=&amp;]+)(=([^&amp;]*))?&quot;, &quot;g&quot;),
                    function ($0, $1, $2, $3) {
                        settings.launch_data[$1] = $3;
                    }
                );
                &#x2F;*jslint unparam: false*&#x2F;
            }
            scorm.debug(settings.prefix + &quot;: Launch Data:&quot;, 4);
            scorm.debug(settings.launch_data, 4);
            settings.mode = scorm.getvalue(&#x27;cmi.mode&#x27;); &#x2F;&#x2F; normal, browse, review
            &#x2F;*
             * Entry is interesting.  You may or may not be able to rely on it. If the LMS sets it you&#x27;d
             * be able identify if this is the first time (ab-intio), or if your resuming.  This would let you know if
             * there was even a bookmark, suspend data to even fetch.  Else, you may have to plug at it anyway.
             * So is it really worth it to bother with this?  Feel free to change the below to fit your needs.
             * In review mode, we will just assume we are actually reviewing a session.  Entry is really void at
             * that point, regardless of what the entry type is.  If the LMS is doing odd stuff, let me know, and I may
             * be able to shed some light on it.
             *&#x2F;
            settings.entry = scorm.getvalue(&#x27;cmi.entry&#x27;); &#x2F;&#x2F; ab-initio, resume or empty
            &#x2F;&#x2F; Entry Check-up ...
            if (settings.mode === &quot;review&quot; || settings.entry === &#x27;&#x27; || settings.entry === &#x27;resume&#x27;) { &#x2F;&#x2F; Resume, or possible Resume
                &#x2F;&#x2F; Get Bookmark
                settings.location = scorm.getvalue(&#x27;cmi.location&#x27;);
                &#x2F;* Suspend Data technically should be a JSON String.  Structured data would be best suited to
                 * be recorded this way.  If you don&#x27;t want to do this, you&#x27;ll need to back out this portion.
                 * Also, in order to eliminate foreign keys and other special characters from messing up some
                 * LMS&#x27;s we commonly escape going out, and unescape coming in.  I noticed this was increasing
                 * the suspend_data string length by almost 50%.  I&#x27;m opting to use a cleanseData() method now
                 * to define a whitelist of safe characters.  We may even need to base64.
                 * !IMPORTANT- once you do this, your kinda stuck with it.  SCO&#x27;s will begin to save suspend data
                 * and if you change mid-stream your going to have to handle the fact you need to reverse support
                 * old saved data.  Don&#x27;t fall victim to this little gem.
                 * GOAL: Deal with this in a managed way
                 *&#x2F;
                settings.suspend_data = (scorm.getvalue(&#x27;cmi.suspend_data&#x27;)); &#x2F;&#x2F; no longer unescaping
                &#x2F;&#x2F; Quality control - You&#x27;d be surprised at the things a LMS responds with
                if (settings.suspend_data.length &gt; 0 &amp;&amp; !isBadValue(settings.suspend_data)) {
                    &#x2F;&#x2F; Assuming a JSON String
                    scorm.debug(settings.prefix + &quot;: Returning suspend data object from a prior session&quot;, 4);
                    settings.suspend_data = JSON.parse(settings.suspend_data); &#x2F;&#x2F; Turn this back into a object.
                    scorm.debug(settings.suspend_data, 4);
                    if (settings.entry === &quot;&quot;) {
                        settings.entry = &quot;resume&quot;;
                    } &#x2F;&#x2F; most definitely its a resume if there is suspend data.
                } else {
                    scorm.debug(settings.prefix + &quot;: Creating new suspend data object&quot;, 4);
                    &#x2F;&#x2F; Object already created by default see settings.suspend_data
                }
            } else {
                &#x2F;&#x2F; First time
                scorm.debug(settings.prefix + &quot;: First time running this SCO based on LMS entry value.&quot;, 4);
                scorm.debug(settings.prefix + &quot;: Creating new suspend data object&quot;, 4);
            }
            &#x2F;&#x2F; Scaled Passing Score
            tmpCompletionThreshold = scorm.getvalue(&#x27;cmi.completion_threshold&#x27;);
            if (!isBadValue(tmpCompletionThreshold) &amp;&amp; tmpCompletionThreshold !== &quot;-1&quot;) {
                settings.completion_threshold = tmpCompletionThreshold;
            }
            &#x2F;&#x2F; Completion Threshold is read-only so it comes from the CAM (imsmanifest.xml) or you manage it yourself.
            tmpScaledPassingScore = scorm.getvalue(&#x27;cmi.scaled_passing_score&#x27;); &#x2F;&#x2F; This may be empty, default otherwise
            if (!isBadValue(tmpScaledPassingScore) &amp;&amp; tmpScaledPassingScore !== &quot;-1&quot;) {
                settings.scaled_passing_score = tmpScaledPassingScore;
                &#x2F;&#x2F; else it defaults to what its set to prior.  i.e. no change.
            }
            settings.completion_status = scorm.getvalue(&#x27;cmi.completion_status&#x27;);
            settings.success_status = scorm.getvalue(&#x27;cmi.success_status&#x27;);
            &#x2F;&#x2F; Lets check for Comments from the LMS
            settings.comments_from_lms = getCommentsFromLMS();
            if (settings.comments_from_lms !== &#x27;false&#x27;) {
                &#x2F;&#x2F; Custom Event Trigger load
                $(self).triggerHandler({
                    &#x27;type&#x27;: &quot;comments_lms&quot;,
                    &#x27;data&#x27;: settings.comments_from_lms
                });
            }
            &#x2F;&#x2F; Check if there is a max_time_allowed
            settings.max_time_allowed = scorm.getvalue(&#x27;cmi.max_time_allowed&#x27;);
            if (isISO8601Duration(settings.max_time_allowed)) {
                if (settings.initiate_timer) {
                    scorm.debug(settings.prefix + &quot;: This SCO has a set time, I am starting the timer for &quot; + settings.max_time_allowed + &quot;...&quot;);
                    self.startTimer();
                }
            } else {
                scorm.debug(settings.prefix + &quot;: This is not ISO8601 time duration. &quot; + settings.max_time_allowed);
            }
        } else {
            scorm.debug(settings.prefix + &quot;: You already called start!  I don&#x27;t see much point in doing this more than once.&quot;, 2);
            return false;
        }
        return true;
    };
    &#x2F;**
     * Set Totals
     * This will take in total objectives, interactions, score max and score min to aid
     * in the calculation of a score rollup.
     * @param data {Object}
     * {
     *  totalInteractions: &#x27;0&#x27;,
     *  totalObjectives: &#x27;0&#x27;,
     *  scoreMin: &#x27;0&#x27;,
     *  scoreMax: &#x27;0&#x27;
     * }
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.setTotals = function (data) {
        if (isStarted) {
            if (!isBadValue(data.totalInteractions)) {
                settings.totalInteractions = data.totalInteractions;
            }
            if (!isBadValue(data.totalObjectives)) {
                settings.totalObjectives = data.totalObjectives;
            }
            if (!isBadValue(data.scoreMin)) {
                settings.scoreMin = trueRound(data.scoreMin, 7);
                scorm.setvalue(&#x27;cmi.score.min&#x27;, data.scoreMin.toString());
            }
            if (!isBadValue(data.scoreMax)) {
                settings.scoreMax = trueRound(data.scoreMax, 7);
                scorm.setvalue(&#x27;cmi.score.max&#x27;, data.scoreMax.toString());
            }
            return &#x27;true&#x27;;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Start Timer
     * This will begin the timer based on the time provided by max_time_allowed.  This depends on the time_limit_action.
     *&#x2F;
    this.startTimer = function () {
        var time = scorm.ISODurationToCentisec(settings.max_time_allowed) * 10;
        setTimeout(timesUp, time);
    };
    &#x2F;**
     * Debug
     * Relay so you don&#x27;t have to say scorm vs SB
     * @type {*} *see SCORM_API debug
     *&#x2F;
    this.debug = scorm.debug;
    &#x2F;**
     * Get Value
     * Relay so you can keep talking to SCOBot for one-to-one SCORM calls.
     * @type {*|Function} *see SCORM_API getvalue
     *&#x2F;
    this.getvalue = scorm.getvalue;
    &#x2F;**
     * Set Value
     * Relay so you can keep talking to SCObot for one-to-one SCORM calls.
     * @type {*|Function} *see SCORM_API setvalue
     *&#x2F;
    this.setvalue = scorm.setvalue;
    &#x2F;**
     * Get Mode
     * This will return the current SCO Mode we are in (normal, browse, review)
     * @returns {String} normal, browse, review
     *&#x2F;
    this.getMode = function () {
        if (isStarted) {
            return settings.mode;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Get Entry
     * This will return the entry type (ab-initio, resume or &quot;&quot;)
     * @returns {String} ab-initio, resume , &quot;&quot;
     *&#x2F;
    this.getEntry = function () {
        if (isStarted) {
            return settings.entry;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Set Bookmark
     * This will update the local snap shot, and update SCORM (commit still required)
     * @param v {String} value
     * returns {String} &#x27;true&#x27; or &#x27;false&#x27;.
     *&#x2F;
    this.setBookmark = function (v) {
        if (isStarted) {
            settings.location = v.toString(); &#x2F;&#x2F; update local snapshot, ensure string
            return scorm.setvalue(&#x27;cmi.location&#x27;, settings.location);
        }
        return notStartedYet();
    };
    &#x2F;**
     * Get Bookmark
     * This will return the local snapshot, but is in sync with cmi.location
     * @returns {String} bookmark
     *&#x2F;
    this.getBookmark = function () {
        if (isStarted) {
            return settings.location; &#x2F;&#x2F; return local snapshot
        }
        return notStartedYet();
    };
    &#x2F;**
     * Progress
     * Hooks to Private method used possibly elsewhere in this API
     * cmi.score.scaled,
     * cmi.success_status,
     * cmi.completion_status,
     * cmi.progress_measure
     * @returns {Object}
     *&#x2F;
    this.progress = checkProgress;
    &#x2F;**
     * Set Suspend Data By Page ID
     * This will set the suspend data by id (could be a page ID as long as its unique)
     * Suspend data is a 64,000 character string.  In this case it will be a JSON Object that
     * freely converts to a JSON String or Object.
     * Now you could require that the end user have a id in their data object, or in this case keep it
     * separate for search ability.  Either way you&#x27;ll have to verify they are passing a id.
     * I&#x27;ve opted to make them pass the ID.  I&#x27;m also opting to keep this as a object instead of
     * just a page array.  You may want to add more things to suspend data than just pages.
     * Example structure of this:
     * {
     *  sco_id: &#x27;12345&#x27;,
     *  name: &#x27;value&#x27;,
     *  pages: [
     *      {
     *          id: 1,
     *          title: &#x27;Presentation&#x27;,
     *          data: {data object for a page}
     *      },
     *      {
     *          id: 2,
     *          title: &#x27;Match Game&#x27;,
     *          data: {data object for a page}
     *     }
     *  ]
     * };
     * Calling commit will still be needed to truly save it.
     * @param id {*}
     * @param title {String}
     * @param data {Object}
     * @returns {String}
     *&#x2F;
    this.setSuspendDataByPageID = function (id, title, data) {
        if (isStarted) {
            &#x2F;&#x2F; Suspend data is a array of pages by ID
            var i = 0,
                len = settings.suspend_data.pages.length;
            &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
            while (i &lt; len) {
                if (settings.suspend_data.pages[i].id === id) {
                    &#x2F;&#x2F; Update Page data
                    settings.suspend_data.pages[i].data = data; &#x2F;&#x2F; overwrite existing
                    scorm.debug(settings.prefix + &quot;: Suspend Data Set&quot;, 4);
                    scorm.debug(settings.suspend_data, 4);
                    return setSuspendData();
                    &#x2F;&#x2F;return &#x27;true&#x27;;
                }
                i += 1;
            }
            &#x2F;&#x2F; new page push
            settings.suspend_data.pages.push({&#x27;id&#x27;: id, &#x27;title&#x27;: title, &#x27;data&#x27;: data});
            scorm.debug(settings.prefix + &quot;: Suspend Data set:&quot;, 4);
            scorm.debug(settings.suspend_data, 4);
            return setSuspendData();
            &#x2F;&#x2F;return &#x27;true&#x27;;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Get Suspend Data By Page ID
     * This will get the suspend data by id
     * @param id {*}
     * @returns {*} object, but false if empty.
     *&#x2F;
    this.getSuspendDataByPageID = function (id) {
        if (isStarted) {
            &#x2F;&#x2F; Suspend data is a array of pages by ID
            var i = 0,
                len = settings.suspend_data.pages.length;
            &#x2F;&#x2F;for (i = 0; i &lt; len; i += 1) {
            while (i &lt; len) {
                if (settings.suspend_data.pages[i].id === id) {
                    return settings.suspend_data.pages[i].data;
                }
                i += 1;
            }
            return &#x27;false&#x27;;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Get Time From Start
     *
     *&#x2F;
    this.getSecondsFromStart = function () {
        return settings.startTime - currentTime(); &#x2F;&#x2F; turn in to seconds
    };
    &#x2F;**
     * Set Interaction
     * This will set an interaction based on Journaling or State.
     * Parameter for choosing a version is located in the defaults.
     * Note: If you are recording Journaling make sure its something the LMS
     * supports or plans to support, or your just blimping out your interactions array
     * for no reason.
     * You may ask what is &quot;real(10,7)&quot;.  This is a binary floating point with a precision up to 7 characters to the right of the decimal.
     * Example Data Object:
     * {
     *  id: &#x27;1&#x27;,                             &#x2F;&#x2F; 4000 chars
     *  type: &#x27;true-false&#x27;,                  &#x2F;&#x2F; (true-false, choice, fill-in, long-fill-in, matching, performance, sequencing, likert, numeric, other)
     *  objectives: [
     *    {
     *       id: &#x27;12&#x27;
     *    }
     *  ],
     *  timestamp: &#x27;expects date object when interaction starts&#x27;,  &#x2F;&#x2F; second(10,0) Pass a date object
     *  correct_responses: [
     *      {
     *          pattern: &#x27;&#x27;                  &#x2F;&#x2F; depends on interaction type
     *      }
     *  ],
     *  weighting: &#x27;1&#x27;,
     *  learner_response: &#x27;true&#x27;,
     *  result: &#x27;correct&#x27;,                   &#x2F;&#x2F; (correct, incorrect, unanticipated, neutral, real (10,7) )
     *  latency: &#x27;expects date object after interaction is done&#x27;,  &#x2F;&#x2F; second(10,2)
     *  description: &quot;The question commonly&quot; &#x2F;&#x2F; 250 chars
     * }
     * @param data {Object} Interaction Object from SCORM
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.setInteraction = function (data) {
        if (isStarted) {
            var n, &#x2F;&#x2F; Reserved for the count within interactions.n
                m, &#x2F;&#x2F; Reserved for the count within interactions.n.objectives.m
                i, &#x2F;&#x2F; Reserved for objective loop
                j, &#x2F;&#x2F; Reserved for correct responses loop
                p, &#x2F;&#x2F; Reserved for the count within interactions.n.ncorrect_responses.p loop
                p1 = &#x27;cmi.interactions.&#x27;, &#x2F;&#x2F; Reduction of retyping
                p2, &#x2F;&#x2F; Reduction of retyping
                orig_timestamp = data.timestamp || scorm.isoStringToDate(scorm.getvalue(p1 + scorm.getInteractionByID(data.id) + &#x27;.timestamp&#x27;)),
                timestamp, &#x2F;&#x2F; Reserved for converting the Timestamp
                latency, &#x2F;&#x2F; Reserved for doing the Timestamp to latency conversion (May not exist)
                result, &#x2F;&#x2F; Result of calling values against the SCORM API
            &#x2F;&#x2F;cr,
            &#x2F;&#x2F;cr_hash = &#x27;&#x27;, &#x2F;&#x2F; Correct Response limit is 5.  If you pass duplicates I&#x27;m going to stop it from happening.
                len,
                key;
            if (!$.isPlainObject(data)) {
                scorm.debug(settings.prefix + &quot;: Developer, your not passing a {object} argument!!  Got &quot; + typeof data + &quot; instead.&quot;, 1);
                return &#x27;false&#x27;;
            }
            if (isBadValue(data.id)) {
                &#x2F;&#x2F; This is a show stopper, try to give them some bread crumb to locate the problem.
                scorm.debug(settings.prefix + &quot;: Developer, your passing a interaction without a ID\nSee question:\n&quot; + data.description, 1);
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        scorm.debug(&quot;key: &quot; + key + &quot;\n value: &quot; + data[key]);
                    }
                }
                return &#x27;false&#x27;;
            }
            &#x2F;&#x2F;Time stuff will need to move after ID is added
            &#x2F;&#x2F;if (typeof (data.timestamp) === &quot;object&quot;) {
            if ($.type(data.timestamp) === &quot;date&quot;) {
                timestamp = scorm.isoDateToString(data.timestamp); &#x2F;&#x2F; 2012-02-12T00:37:29 formatted
            }
            data.timestamp = timestamp;
            &#x2F;&#x2F;if (typeof (data.latency) === &quot;object&quot;) {
            if ($.type(data.latency) === &quot;date&quot;) {
                latency = (data.latency.getTime() - orig_timestamp.getTime()) * 0.001;
                data.latency = scorm.centisecsToISODuration(latency * 100, true);  &#x2F;&#x2F; PT0H0M0S
            } else if (data.learner_response.length &gt; 0 &amp;&amp; !isBadValue(data.learner_response)) {
                &#x2F;&#x2F; may want to force latency?
                data.latency = new Date();
                latency = (data.latency.getTime() - orig_timestamp.getTime()) * 0.001;
                data.latency = scorm.centisecsToISODuration(latency * 100, true);  &#x2F;&#x2F; PT0H0M0S
            } &#x2F;&#x2F; Else you won&#x27;t record latency as the student didn&#x27;t touch the question.
            &#x2F;&#x2F; Check for Interaction Mode
            p2 = &#x27;_count&#x27;;
            if (settings.interaction_mode === &quot;journaled&quot;) {
                &#x2F;&#x2F; Explicitly stating they want a history of interactions
                n = scorm.getvalue(p1 + p2) === &quot;-1&quot; ? &#x27;0&#x27; : scorm.getvalue(p1 + p2); &#x2F;&#x2F; we want to use cmi.interactions._count
            } else {
                &#x2F;&#x2F; Default to state, which will update by id
                n = scorm.getInteractionByID(data.id); &#x2F;&#x2F; we want to update by interaction id
                if (isBadValue(n)) {
                    n = scorm.getvalue(p1 + p2) === &quot;-1&quot; ? &#x27;0&#x27; : scorm.getvalue(p1 + p2);
                }
            }
            &#x2F;*
             * We need to make several setvalues now against cmi.interactions.n.x
             * As stated by the standard, if we run into issues they will show in the log from the SCORM API.
             * I won&#x27;t currently do anything at this point to handle them here, as I doubt there is little that could be done.
             *&#x2F;
            p1 += n + &quot;.&quot;; &#x2F;&#x2F; Add n to part 1 str
            if (!isBadValue(data.id)) {
                result = scorm.setvalue(p1 + &#x27;id&#x27;, data.id);
            }
            if (!isBadValue(data.type)) {
                result = scorm.setvalue(p1 + &#x27;type&#x27;, data.type);
            }
            &#x2F;&#x2F; Objectives will require a loop within data.objectives.length, and we may want to validate if an objective even exists?
            &#x2F;&#x2F; Either ignore value because its already added, or add it based on _count
            &#x2F;&#x2F; result = scorm.setvalue(&#x27;cmi.interactions.&#x27;+n+&#x27;.objectives.&#x27;+m+&quot;.id&quot;, data.objectives[i].id);
            p2 = &#x27;objectives._count&#x27;;
            if (data.objectives !== undefined) {
                i = 0;
                len = data.objectives.length;
                while (i &lt; len) {
                &#x2F;&#x2F;for (i = 0; i &lt; data.objectives.length; i += 1) {
                    &#x2F;&#x2F; We need to find out if the objective is already added
                    m = scorm.getInteractionObjectiveByID(n, data.objectives[i].id); &#x2F;&#x2F; will return 0 or the locator where it existed or false (not found)
                    if (m === &#x27;false&#x27;) {
                        m = scorm.getvalue(p1 + p2) === &#x27;-1&#x27; ? &#x27;0&#x27; : scorm.getvalue(p1 + p2);
                    }
                    result = scorm.setvalue(p1 + &#x27;objectives.&#x27; + m + &#x27;.id&#x27;, data.objectives[i].id);
                    i += 1;
                }
            }
            if (data.timestamp !== undefined) {
                result = scorm.setvalue(p1 + &#x27;timestamp&#x27;, data.timestamp);
            }
            &#x2F;&#x2F; Correct Responses Pattern will require a loop within data.correct_responses.length, may need to format by interaction type
            &#x2F;&#x2F;result = scorm.setvalue(&#x27;cmi.interactions.&#x27;+n+&#x27;.correct_responses.&#x27;+p+&#x27;.pattern&#x27;, data.correct_responses[j].pattern);
            p2 = &#x27;correct_responses._count&#x27;;
            if ($.isArray(data.correct_responses)) {
                &#x2F;&#x2F; !! Important, some only support 1 correct response pattern (likert, other) !!
                j = 0;
                len = data.correct_responses.length;
                while (j &lt; len) {
                &#x2F;&#x2F;for (j = 0; j &lt; len; j += 1) {
                    p = scorm.getInteractionCorrectResponsesByPattern(n, data.correct_responses[j].pattern);
                    scorm.debug(settings.prefix + &quot;: Trying to locate pattern &quot; + data.correct_responses[j].pattern + &quot; resulted in &quot; + p, 4);
                    if (p === &#x27;false&#x27;) {
                        p = scorm.getvalue(p1 + p2) === &#x27;-1&#x27; ? 0 : scorm.getvalue(p1 + p2);
                        scorm.debug(settings.prefix + &quot;: p is now &quot; + p, 4);
                    }
                    if (p === &quot;match&quot;) {
                        scorm.debug(settings.prefix + &quot;: Developer, I&#x27;ve already added this correct response type &#x27;&quot; + data.correct_responses[j].pattern + &quot;&#x27;&quot;, 2);
                    } else {
                        result = scorm.setvalue(p1 + &#x27;correct_responses.&#x27; + p + &#x27;.pattern&#x27;, encodeInteractionType(data.type, data.correct_responses[j].pattern));
                    }
                    j += 1;
                }
            } else {
                scorm.debug(settings.prefix + &quot;: Something went wrong with Correct Responses, it wasn&#x27;t an Array.&quot;, 1);
            }
            if (!isBadValue(data.weighting)) {
                result = scorm.setvalue(p1 + &#x27;weighting&#x27;, data.weighting);
            }
            if (!isBadValue(data.learner_response)) {
                result = scorm.setvalue(p1 + &#x27;learner_response&#x27;, encodeInteractionType(data.type, data.learner_response));
            } &#x2F;&#x2F; will need to format by interaction type
            if (!isBadValue(data.result)) {
                result = scorm.setvalue(p1 + &#x27;result&#x27;, data.result);
            }
            if (!isBadValue(data.latency)) {
                result = scorm.setvalue(p1 + &#x27;latency&#x27;, data.latency);
            }
            if (!isBadValue(data.description)) {
                result = scorm.setvalue(p1 + &#x27;description&#x27;, data.description);
            }
            return result;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Get Interaction
     * Returns the full Interaction object
     * @param id {String}
     * @returns {*} object or string &#x27;false&#x27;
     * {
     *  id: &#x27;1&#x27;,                             &#x2F;&#x2F; 4000 chars
     *  type: &#x27;true-false&#x27;,                  &#x2F;&#x2F; (true-false, choice, fill-in, long-fill-in, matching, performance, sequencing, likert, numeric, other)
     *  objectives: [
     *      {
     *          id: &#x27;12&#x27;
     *      }
     *  ],
     *  timestamp: &#x27;expects date object when interaction starts&#x27;,  &#x2F;&#x2F; second(10,0) Pass a date object
     *  correct_responses: [
     *      {
     *          pattern: &#x27;&#x27;                  &#x2F;&#x2F; depends on interaction type
     *      }
     *  ],
     *  weighting: &#x27;1&#x27;,
     *  learner_response: &#x27;true&#x27;,
     *  result: &#x27;correct&#x27;,                   &#x2F;&#x2F; (correct, incorrect, unanticipated, neutral, real (10,7) )
     *  latency: &#x27;expects date object after interaction is done&#x27;,  &#x2F;&#x2F; second(10,2)
     *  description: &quot;The question commonly&quot; &#x2F;&#x2F; 250 chars
     * }
     * or
     * &#x27;false&#x27;
     *&#x2F;
    this.getInteraction = function (id) {
        if (isStarted) {
            var n, &#x2F;&#x2F; Interaction count
                p1 = &#x27;cmi.interactions.&#x27;, &#x2F;&#x2F; Reduction of typing
                m, &#x2F;&#x2F; objectives count
                p, &#x2F;&#x2F; correct_responses count
                i = 0, &#x2F;&#x2F; loop count
                obj = {}, &#x2F;&#x2F; Response object
                ts, &#x2F;&#x2F; temp
                ly, &#x2F;&#x2F; temp
                timestamp, &#x2F;&#x2F; for converting to date object
                latency; &#x2F;&#x2F; for converting to date object
            n = scorm.getInteractionByID(id);
            if (n === &#x27;false&#x27;) {
                return n;
            }
            &#x2F;&#x2F; Lets rebuild the Interaction object
            p1 += n + &#x27;.&#x27;;
            obj.id = id;
            obj.type = scorm.getvalue(p1 + &#x27;type&#x27;);
            m = scorm.getvalue(p1 + &#x27;objectives._count&#x27;);
            &#x2F;&#x2F; Fix the time stamps up ...
            ts = scorm.getvalue(p1 + &#x27;timestamp&#x27;);
            ly = scorm.getvalue(p1 + &#x27;latency&#x27;);
            timestamp = (isISO8601(ts)) ? scorm.isoStringToDate(ts) : ts;
            latency = (isISO8601(ly)) ? scorm.isoStringToDate(ly) : ly;
            &#x2F;&#x2F; End
            obj.objectives = [];
            if (m !== &#x27;false&#x27;) {
                &#x2F;&#x2F;m -= 1; &#x2F;&#x2F; Subtract one since the _count is the next avail slot
                while (i &lt; m) {
                &#x2F;&#x2F;for (i = 0; i &lt; m; i += 1) {
                    obj.objectives.push({
                        id: scorm.getvalue(p1 + &#x27;objectives.&#x27; + i + &#x27;.id&#x27;)
                    });
                    i += 1;
                }
            }
            obj.timestamp = timestamp;
            p = scorm.getvalue(p1 + &#x27;correct_responses._count&#x27;);
            obj.correct_responses = [];
            if (p !== &#x27;false&#x27;) {
                &#x2F;&#x2F; Loop thru and grab the patterns
                i = 0;
                while (i &lt; p) {
                &#x2F;&#x2F;for (i = 0; i &lt; p; i += 1) {
                    obj.correct_responses.push({
                        pattern: decodeInteractionType(obj.type, scorm.getvalue(p1 + &#x27;correct_responses.&#x27; + i + &#x27;.pattern&#x27;))
                    });
                    i += 1;
                }
            }
            obj.weighting = scorm.getvalue(p1 + &#x27;weighting&#x27;);
            obj.learner_response = decodeInteractionType(obj.type, scorm.getvalue(p1 + &#x27;learner_response&#x27;));
            obj.result = scorm.getvalue(p1 + &#x27;result&#x27;);
            obj.latency = latency;
            obj.description = scorm.getvalue(p1 + &#x27;description&#x27;);
            return obj;
        }
        return notStartedYet();
    };
    &#x2F;**
     * Set Objective
     * Sets the data for the scorm objective.  ID&#x27;s have to be set first and must be unique.
     * Example data object
     * {
     *  id: &#x27;1&#x27;,                            &#x2F;&#x2F; 4000 chars
     *  score: {
     *      scaled: &#x27;0&#x27;,                    &#x2F;&#x2F; real(10,7) *
     *      raw: &#x27;0&#x27;,
     *      min: &#x27;0&#x27;,
     *      max: &#x27;0&#x27;
     *  }
     *  success_status: &#x27;failed&#x27;,            &#x2F;&#x2F; (passed, failed, unknown)
     *  completion_status: &#x27;incomplete&#x27;,     &#x2F;&#x2F; (completed, incomplete, not attempted, unknown)
     *  progress_measure: &#x27;0&#x27;,               &#x2F;&#x2F; real(10,7)
     *  description: &#x27;This is the objective&#x27; &#x2F;&#x2F; 250 Chars
     * }
     * @param data {Object} Objective object from SCORM
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.setObjective = function (data) {
        if (isStarted) {
            var p1 = &#x27;cmi.objectives.&#x27;,
                n = scorm.getObjectiveByID(data.id),
                result = &#x27;false&#x27;,
                f = false,
                def1 = &quot;: Passed no or bad &quot;,
                def2 = &quot; ignored.&quot;,
                sv = scorm.setvalue,
                key;
            scorm.debug(settings.prefix + &quot;: Setting Objective at &quot; + n + &quot; (This may be false)&quot;);
            if (isBadValue(n)) { &#x2F;&#x2F; First Run
                n = scorm.getvalue(p1 + &#x27;_count&#x27;);
                if (n === &#x27;false&#x27;) {
                    scorm.debug(settings.prefix + &quot;: LMS is return false, can not proceed, check error codes&quot;);
                    return n;
                }
                scorm.debug(settings.prefix + &quot;: Objective &quot; + data.id + &quot; was not found.  Adding new at &quot; + n + &quot; &quot; + data.description);
                f = true;
            }
            p1 += n + &#x27;.&#x27;;
            if (f) {
                if (!isBadValue(data.id)) {
                    sv(p1 + &#x27;id&#x27;, data.id.toString());
                } else { &#x2F;&#x2F; Show stopper
                    scorm.debug(settings.prefix + &quot;: You did not pass an objective ID!!  What I did get below:&quot;, 1);
                    for (key in data) {
                        if (data.hasOwnProperty(key)) {
                            scorm.debug(&quot;key: &quot; + key + &quot;\n value: &quot; + data[key]);
                        }
                    }
                    return &#x27;false&#x27;;
                }
            }
            if ($.isPlainObject(data.score)) {
                result = !isBadValue(data.score.scaled) ? sv(p1 + &#x27;score.scaled&#x27;, trueRound(data.score.scaled, 7).toString()) : scorm.debug(settings.prefix + def1 + p1 + &quot;score.scaled: &quot; + data.score.scaled + def2, 3);
                result = !isBadValue(data.score.raw) ? sv(p1 + &#x27;score.raw&#x27;, trueRound(data.score.raw, 7).toString()) : scorm.debug(settings.prefix + def1 + p1 + &quot;score.raw: &quot; + data.score.raw + def2, 3);
                result = !isBadValue(data.score.min) ? sv(p1 + &#x27;score.min&#x27;, trueRound(data.score.min, 7).toString()) : scorm.debug(settings.prefix + def1 + p1 + &quot;score.min: &quot; + data.score.min + def2, 3);
                result = !isBadValue(data.score.max) ? sv(p1 + &#x27;score.max&#x27;, trueRound(data.score.max, 7).toString()) : scorm.debug(settings.prefix + def1 + p1 + &quot;score.max: &quot; + data.score.max + def2, 3);
            } else {
                scorm.debug(settings.prefix + &quot;: Did not receive a score object.  May or may not be an issue.&quot;, 4);
            }
            result = !isBadValue(data.success_status) ? sv(p1 + &#x27;success_status&#x27;, data.success_status) : scorm.debug(settings.prefix + def1 + p1 + &quot;success_status: &quot; + data.success_status + def2, 3);
            result = !isBadValue(data.completion_status) ? sv(p1 + &#x27;completion_status&#x27;, data.completion_status) : scorm.debug(settings.prefix + def1 + p1 + &quot;completion_status: &quot; + data.completion_status + def2, 3);
            result = !isBadValue(data.progress_measure) ? sv(p1 + &#x27;progress_measure&#x27;, data.progress_measure) : scorm.debug(settings.prefix + def1 + p1 + &quot;progress_measure: &quot; + data.progress_measure + def2, 3);
            result = !isBadValue(data.description) ? sv(p1 + &#x27;description&#x27;, data.description) : scorm.debug(settings.prefix + def1 + p1 + &quot;description: &quot; + data.description + def2, 3);
            scorm.debug(settings.prefix + &quot;: Progress\n&quot; + JSON.stringify(checkProgress(), null, &quot; &quot;), 4);
            return result.toString();
        }
        return notStartedYet();
    };
    &#x2F;**
     * Get Objective
     * Returns the Objective object by ID
     * @param id {String}
     * @returns {*} object or string &#x27;false&#x27;
     * {
     *  id: &#x27;1&#x27;,                            &#x2F;&#x2F; 4000 chars
     *  score: {
     *      scaled: &#x27;0&#x27;,                    &#x2F;&#x2F; real(10,7) *
     *      raw: &#x27;0&#x27;,
     *      min: &#x27;0&#x27;,
     *      max: &#x27;0&#x27;
     *  }
     *  success_status: &#x27;failed&#x27;,            &#x2F;&#x2F; (passed, failed, unknown)
     *  completion_status: &#x27;incomplete&#x27;,     &#x2F;&#x2F; (completed, incomplete, not attempted, unknown)
     *  progress_measure: &#x27;0&#x27;,               &#x2F;&#x2F; real(10,7)
     *  description: &#x27;This is the objective&#x27; &#x2F;&#x2F; 250 Chars
     * }
     * or
     * &#x27;false&#x27;
     *&#x2F;
    this.getObjective = function (id) {
        if (isStarted) {
            var n = scorm.getObjectiveByID(id),
                p1 = &#x27;cmi.objectives.&#x27;;
            if (n === &#x27;false&#x27;) {
                return n;
            }
            p1 += n + &quot;.&quot;;
            &#x2F;&#x2F; Build Response
            return {
                id:                scorm.getvalue(p1 + &quot;id&quot;),
                score:             {
                    scaled: scorm.getvalue(p1 + &quot;score.scaled&quot;),
                    raw:    scorm.getvalue(p1 + &quot;score.raw&quot;),
                    min:    scorm.getvalue(p1 + &quot;score.min&quot;),
                    max:    scorm.getvalue(p1 + &quot;score.max&quot;)
                },
                success_status:    scorm.getvalue(p1 + &quot;success_status&quot;),
                completion_status: scorm.getvalue(p1 + &quot;completion_status&quot;),
                progress_measure:  scorm.getvalue(p1 + &quot;progress_measure&quot;),
                description:       scorm.getvalue(p1 + &quot;description&quot;)
            };
        }
        return notStartedYet();
    };
    &#x2F;**
     * Set Comment From Learner
     * This will set the comment, location and time the student made a comment
     * @param msg {String} comment
     * @param loc {String} location
     * @param date {Object} New Date object (for timestamp)
     * @return {String}
     *&#x2F;
    this.setCommentFromLearner = function (msg, loc, date) {
        if (isStarted) {
            var p1 = &quot;cmi.comments_from_learner.&quot;,
                n = scorm.getvalue(p1 + &quot;_count&quot;);
            if (n === &#x27;false&#x27;) {
                scorm.debug(settings.prefix + &quot;: Sorry, LMS returned a comments count of &#x27;false&#x27;.  Review error logs.&quot;);
                return n;
            }
            if (msg.length === 0 || msg.length &gt; 4000) {
                scorm.debug(settings.prefix + &quot;: Sorry, message from learner was empty or exceeded the limit. Length:&quot; + msg.length, 2);
            }
            p1 += n + &#x27;.&#x27;;
            scorm.setvalue(p1 + &#x27;comment&#x27;, msg);
            scorm.setvalue(p1 + &#x27;location&#x27;, loc);
            return scorm.setvalue(p1 + &#x27;timestamp&#x27;, scorm.isoDateToString(date));
        }
        return notStartedYet();
    };
    &#x2F;**
     * Grade It
     * This method will set cmi.score.scaled, cmi.success_status, and cmi.completion_status.  This is for situations
     * where you are doing simple scoring, with NO objectives or interactions.
     * Prereq for this would be to have passed in scaled_passing_score and completion_threshold in to SCOBot
     * If none are provided it will default to &#x27;passed&#x27; and &#x27;completed&#x27;
     * Special Note: If you are using Objectives, Interactions and set the totals, you do not need to use this method.
     * @return {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.gradeIt = function () {
        var scoreScaled = 1,
            scoreRaw = scorm.getvalue(&#x27;cmi.score.raw&#x27;),
            scoreMin = scorm.getvalue(&#x27;cmi.score.min&#x27;),
            scoreMax = scorm.getvalue(&#x27;cmi.score.max&#x27;),
            progressMeasure = scorm.getvalue(&#x27;cmi.progress_measure&#x27;);
        &#x2F;&#x2F; Set Score Scaled
        if ((scoreMax - scoreMin) === 0) {
            &#x2F;&#x2F; Division By Zero
            scorm.debug(settings.prefix + &quot;: Division by Zero for scoreMax - scoreMin &quot; + scoreMax, 2);
            scorm.setvalue(&#x27;cmi.score.scaled&#x27;, scoreScaled);
        } else {
            scoreScaled = ((scoreRaw - scoreMin) &#x2F; (scoreMax - scoreMin)).toString();
            scorm.debug(settings.prefix + &quot;: Score Scaled = &quot; + scoreScaled, 3);
            scorm.setvalue(&#x27;cmi.score.scaled&#x27;, trueRound(scoreScaled, 7));
        }
        &#x2F;&#x2F; Set Completion Status
        settings.completion_status = (parseFloat(progressMeasure) &gt;= parseFloat(settings.completion_threshold)) ? &#x27;completed&#x27; : &#x27;incomplete&#x27;;
        scorm.setvalue(&#x27;cmi.completion_status&#x27;, settings.completion_status);
        &#x2F;&#x2F; Set Success Status
        settings.success_status = (parseFloat(scoreScaled) &gt;= parseFloat(settings.scaled_passing_score)) ? &#x27;passed&#x27; : &#x27;failed&#x27;;
        scorm.setvalue(&#x27;cmi.success_status&#x27;, settings.success_status);
        return &#x27;true&#x27;;
    };
    &#x2F;**
     * Happy Ending
     * This will auto-score the student to passed, completed, and scored
     * @return {String}
     *&#x2F;
    this.happyEnding = function () {
        if (isStarted) {
            scorm.setvalue(&#x27;cmi.score.scaled&#x27;, &#x27;1&#x27;);
            scorm.setvalue(&#x27;cmi.score.min&#x27;, &#x27;0&#x27;);
            scorm.setvalue(&#x27;cmi.score.max&#x27;, &#x27;1&#x27;);
            scorm.setvalue(&#x27;cmi.score.raw&#x27;, &#x27;1&#x27;);
            scorm.setvalue(&#x27;cmi.success_status&#x27;, &#x27;passed&#x27;);
            scorm.setvalue(&#x27;cmi.progress_measure&#x27;, &#x27;1&#x27;);
            return scorm.setvalue(&#x27;cmi.completion_status&#x27;, &#x27;completed&#x27;);
        }
        return notStartedYet();
    };
    &#x2F;**
     * Commit
     * This will commit the data stored at the LMS Level to the backend.  Please use sparingly.
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.commit = function () {
        if (isStarted) {
            return scorm.commit(&#x27;&#x27;);
        }
        return notStartedYet();
    };
    &#x2F;**
     * Suspend
     * This will suspend the SCO and ends with terminating.  No data can be saved after this.
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.suspend = function () {
        if (isStarted) {
            scorm.debug(settings.prefix + &quot;: I am suspending...&quot;, 3);
            scorm.setvalue(&#x27;cmi.exit&#x27;, &#x27;suspend&#x27;);
            updateStatus();
            isStarted = false;
            return scorm.terminate();
        }
        return notStartedYet();
    };
    &#x2F;**
     * Finish
     * This will set success status, exit and completion
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.finish = function () {
        if (isStarted) {
            scorm.debug(settings.prefix + &quot;: I am finishing...&quot;, 3);
            scorm.setvalue(&#x27;cmi.exit&#x27;, &#x27;normal&#x27;);
            updateStatus();
            &#x2F;&#x2F; This is completed per this call.
            isStarted = false;
            return scorm.terminate();
        }
        return notStartedYet();
    };
    &#x2F;**
     * Timeout
     * This will set success status, exit and completion
     * @returns {String} &#x27;true&#x27; or &#x27;false&#x27;
     *&#x2F;
    this.timeout = function () {
        if (isStarted) {
            scorm.debug(settings.prefix + &quot;: I am timing out...&quot;, 3);
            scorm.setvalue(&#x27;cmi.exit&#x27;, &#x27;time-out&#x27;);
            updateStatus();
            &#x2F;&#x2F; This is completed per this call.
            isStarted = false;
            return scorm.terminate();
        }
        return notStartedYet();
    };
    &#x2F;**
     * Is ISO 8601 UTC
     * @returns {Boolean} true&#x2F;false
     *&#x2F;
    this.isISO8601 = isISO8601;
    &#x2F;**
     * Set
     * This locally sets values local to this API
     * @param n {String} name
     * @param v (String,Number,Object,Array,Boolean} value
     * @return {Boolean}
     *&#x2F;
    this.set = function (n, v) {
        &#x2F;&#x2F; May need to maintain read-only perms here, case them out as needed.
        switch (n) {
        case &quot;version&quot;:
        case &quot;createDate&quot;:
        case &quot;modifiedDate&quot;:
        case &quot;prefix&quot;:
            triggerWarning(405);
            break;
        default:
            settings[n] = v;
            break;
        }
        return (isError === false);
    };
    &#x2F;**
     * Get
     * This locally gets values local to this API
     * @param n {String} name
     * @returns {*} value or {Boolean} false
     *&#x2F;
    this.get = function (n) {
        if (settings[n] === undefined) {
            triggerWarning(404);
            return false;
        }
        return settings[n];
    };
    &#x2F;&#x2F; End Public &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;**
     * Wrap up Constructor
     * Certain versions of mozilla had an issue with not firing the window unload event.
     * At the time, I used window.top to get around this.  Later I started seeing with JQuery
     * different behavior once I incorporated it.  So at this point I&#x27;m using window not window.top.
     *&#x2F;
    $(window).bind(&#x27;load&#x27;, initSCO);
    &#x2F;&#x2F;$(window).bind(&#x27;beforeunload&#x27;, exitSCO); &#x2F;&#x2F; You want to confirm exit?
    $(window).bind(&#x27;unload&#x27;, exitSCO);
    &#x2F;&#x2F;$(window.top).bind(&#x27;unload&#x27;, exitSCO); &#x2F;&#x2F; for those ugly situations
    &#x2F;&#x2F; Listen for SCORM API Exception
    $(scorm).on(&#x27;exception&#x27;, function (e) {
        triggerException(e.error);
    });
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
